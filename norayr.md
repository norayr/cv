---
name: Norayr Chilingarian
keywords: programming languages, translation techniques, lexical analysis, syntax analysis, code generation, ebnf, syntax notation, context-free grammar, recourcsive descent parser, top-down parser, modular programming languages, module, safe programming, secure programming, machine code, operating systems design, dynamic module loading, linking, dynamic linking, oop, kernel, micro-kernel operating systems, oberon, oberon-2, native oberon, vishap oberon compiler, voc, active oberon, active objects, a2, aos, bluebottle, minix, plan9, inferno, threads, tasks, component systems, inter-process communication, package management, dependency resolution. 
left-column:
- 'programming languages'
- 'compiler construction'
- 'operating systems'
- 'systems programming'
right-column:
- 'email: [norayr@arnet.am](mailto:norayr@arnet.am)'
- 'xmpp:  [norayr@spyurk.am](mailto:norayr@arnet.am)'
- 'web: [https://norayr.am/](https://norayr.am/)'
- 'gemini: [gemini://norayr.am/](gemini://norayr.am/)'
- 'ssb:   @Y4+9YYlGp6rS2f7c1Phz7b+cpcQ8Ar9bTxN206Dem5o=.ed25519'
- 'github: [https://github.com/norayr/](https://github.com/norayr/)'
- 'age:  \themyage{} '
- 'this document was compiled: \today'
...

# Education
1994-1998; State Engineering University of Armenia

# Work experiences

## AUA
2017-; adjunct lecturer. 'Operating systems', 'Compiler Design', 'Computer Organization' courses.

## ISTC
2020; instructor, Security Engineering course.

## ACA
2019; instructor, introduction to Linux for non-IT students.

## Vishap Oberon Compiler
2012-; founder and developer of [voc](https://github.com/vishaps/voc)
       lead development of vipack package manager.

## barcamp.am
2010-; member of barcampevn organizing committee.

## Synopsys Armenia
2009-; IT engineer

* Solving problems, consulting developers in areas of systems programming, Unix, distributed computations, maintain and develop Synopsys Armenia and Synopsys/SEUA educational department IT infrastructure, including but not limited with: computational grids(UGE), On Demand Computing (openstack), storage system clusters, monitoring, DNS, CUPS, NIS, dhcp, etc services. Administering a network of more than 500 servers.
* Built custom kernels and software for Engineering teams and Educational departments.
* Set up two Educational departments infrastructure: in Yerevan and Gyumri Synopsys Educational Centers, including Kickstart, NIS, DNS, DHCP, autofs, NFS. Wrote a web interface for the management to administer NIS accounts. Supported maintainance of educational departments in RAU and European universities.
* Have been a research supervisor at Synopsys/SEUA educational department for several years.

## ETH Zurich
2007-2008; Assistant at Native Systems Group, Institute of Computer Systems, ETH Zurich.

* Ported latest (back then) edition of Revised Oberon compiler by Niklaus Wirth from StrongArm to x86 on GNU+Linux.

## Lycos Europe
2004-2007; Member of 'search team'.

* Participated in web search software development (it was running on fireball.de, paperball.de, lycos.eu) and port from TRU64 to GNU+Linux.
* Prepared standard of development environment.
* Patching software, including Apache web server and Spread messaging server.
* Maintaining debian apt archive mirror.
* Managed environment with more than 80 servers.
* Many research works.

## Technology Management Centre of Yerevan Municipality.
2003-2004; IT engineer.

* Unix (FreeBSD) servers administration: DNS, mail, file sharing, proxy, time servers, traffic shapers, routing setup.
* Secure network design by using virtualization (jail) and DMZ setups.
* Monitoring setup with Nagios, which back then was not supported on FreeBSD and needed to be adapted.
* Yerevan Municipality network and information area plan-concept and implementation.

## 'Informsvyaz' ISP (telex221.ru), Dubna, Russia.
2001-2002; Technical direcor.

* I had the opportunity to design and lead the implementation of the ISP from scratch: dial-up access, DSL leased lines, user management, quotas, email server with antivirus, hosting and more.
* Servers were running RedHat & Gentoo Linux, OpenBSD, Windows NT.

## Int@rnet ISP, Yerevan.
2000-2002; System administrator.

* Dial up servers configuration (Ascend, Patton)
* Got first experiente in Unix and network configuration with many services.
* Leased line and dial-up clients.
* Aironet radio modems.
* Quick reconstruction of networks.
* Security audit of web software.

## other
In late 90ies/early 2000s  I also worked as creative director at TV companies(Ar, Noyan Tapan), directed and edited commercials, music clips, short films, etc.

## personality
curious, creative. love sharing knowledge and learning.

# Summary (with pieces of bio)

Sorry for the following essay, but its form, if not content, may describe me better than the 'Experiences' section.

I believe it is fair to describe myself as a curious and open person. But not as a particularly smart person, as you'll be convinced by taking a look at the text below.

It so happened that I am very interested in humans and in technologies, particularly in computers, and human-computer interaction.

Probably that's because I was directed into the area since childhood, was extremely privileged to own and use an 8bit computer. Nobody asked if I wanted that, but I am very thankful.

Though we had a shortage of books and magazines about computers in Soviet Armenia, and I had no one to ask questions, that was also a great learning experience: I learnt to be patient, I learnt to think for days, and stare at code for weeks, try things for months, I learnt that I'll inevitably understand what I want to, it just takes time.

To give the reader more context, back then I even learnt to read (and sometimes understand) the compiled machine code in hexadecimal representation, edit it, hack games, and gain immortality. That also doesn't work exactly like that in life, right? Or maybe no?

By reading the machine code of the old games I learnt many tricks (like self-modifying code) that do not always represent an academic way of programming. I am an advocate of the academic ways today, in case you wonder.

Then at the university, I worked with some outdated machines running MS-DOS, developed some primitive AI programs, and when I was back from the army I faced that 'Windows' (tm) system for the first time.

At the time I was not able to conduct even simple tasks with it, and people around were convinced me and computers have no connection whatsoever.

I did not look confident when touching the mouse, and nobody would suspect I did know how CPU's work and that my native language was a nmos6502 machine code: the CPU you may have interacted with if you met Apple ][, NES, Commodore, small Ataris, Oric or Soviet Agat systems.

It took some time and work and I was able to buy an outdated Pentium machine, and a couple of years later I was building my own Linux distributions from the source code, in a way I like to. Till today I use systems that I build myself from scratch.

Since contemporary systems are overly complicated, I keep my personal systems simple and minimal. It's easier to build, update, mantain, understand them that way.

Back to the story, that was a time when I got access to the Internet, discovered different technologies, and started reading research papers. I wish I got Internet earlier, it would help to start understanding earlier w h a t  i s  s c i e n c e  a b o u t.

Later I realized that programs I have been written in that time frame could be described as systems programming:  that software layer end-user doesn't interact with. I also love to design tools, that other people may use to program. Back then I wrote code generators, my Unix shell, dependency resolving package manager.

Some people perceive me as a 'Unix guy'. However, I believe that's not the case. I think today we know more about operating systems design, but backward compatibility keeps us back. I love to point out the signs of an old design in Unix, Windows, and macOS, and to tell about new approaches in research operating systems: Oberon family systems, Plan9, Inferno.

Still, I also appreciate the history and evolution of computer systems, and I do not blame but admire computer scientists who brought us the design we consider old today. 

I was so obsessed with Oberon technologies, that I somehow reached Switzerland, went to ETH Zurich, and even met the scientists I admired. Then I was lucky to be offered a job in the research group of N. Wirth(he was already retired, but he still works on many projects and sometimes comes to the faculcy), under the supervision of prof. J. Gutknecht, the other author of the Oberon system. There, while working at Native Systems Group, Institute of Computer Systems, ETH Zurich, I have ported N. Wirth's brand new Oberon-07 compiler to x86/Linux.

I am proud that I was called 'Encyclopedia Oberonica' by some members of the research group because I've read an incredible amount of Oberon-related scientific papers and they noticed I do refer to those papers sometimes.

Later I founded a libre software project, Vishap Oberon Compiler, which became well known in the community.  

Today my interests include hardware design and abstractions over it: programming languages, translation techniques, and operating systems. I am also interested in tools and working environment design.

I can describe myself as a digital minimalist: I avoid using many software and 'services'.  

I also value minimalistic design because complicating the design leads to inconsistencies and future problems, and I think too often we are busy solving problems that we have created ourselves. Also, more links in the chain - more possibility that something will break - less safety/stability.

I often suggest thinking more before adding a feature - once you add it, it's very hard to get rid of. When I do a design decision, and I don't see a good enough solution - I believe no solution is better than a bad solution, otherwise, later development on top of a bad solution will be very hard or impossible to roll back.

Did the reader wonder why "computers" work so "slowly" and "unreliably"? That's one of the reasons why.

The other advantage of minimalism is understandable design. I do like to look 'under the hood' and make sense of others' thoughts. That's not an easy task even for people much smarter than me, even when the software is simple. Alas, some software layers humans built are not only impossible to understand for other humans, but even to use.

I believe it is better to search for simple solutions for complicated problems. For sure, I would not encourage the opposite: finding complex solutions when the simpler would suffice.

Such design solutions lead to software that is easier to compromise. One of my major interests is techniques to increase software safety and security.

The approaches I described above would not be celebrated in industry work, where the goal is often to add more features, be fast and early on the market.

I advocate decentralized communication, I believe that the Internet is more than an access channel to a couple of big service providers. That is why I also host and maintain several nodes of decentralized 'social' networks for local communities.

I am obsessed with programming language design. I do believe the language we write in impacts the way we think. Expressing thoughts in a well-designed programming language helps to prevent software failures, hard-to-find errors, security flaws, and vulnerabilities. Using well-designed language teaches programmers the discipline they may benefit from, even when they have to work with not-so-well-designed programming languages.

My favourite programming languages are Oberon, Modula-3, Go.

I value Ada, Spark, Pascal(Extended, ISO standard), Swift, Rust, Forth, Erlang, Haskell, Lisp, Scala, Lua.

I would also say I value C and Objective C, but with a clause: they were created by brilliant computing pioneers when we were not aware of better design principles, and they still carry our past.

The past has a tendency to haunt us and keep us back.

Thank you for reading to this point.

links
=====

compiler related
=========

i was interested in compilers already long ago, let's say [this](https://sourceforge.net/projects/nmos6502-oo2c/files/) is my port of oo2c oberon compiler to nmos6502 cpu based platforms, published in 2007.
[it](https://github.com/norayr/nmos6502-oo2c) is customized to generate 6502 code by using cc65.

* avr oberon-07
[this](https://github.com/norayr/oberon-07_avr_oo2c) is a port of oberon-07 compiler for avr which was running under A2 operating system to Linux or Windows host system by using oo2c compiler.

more serious:

* o7c, x86 backend, done during 200{7,8} work at ETHZ:

[o7c compiler](https://github.com/norayr/o7c)

i also prepared a minimal runtime library for it, and some tests.

[these](https://github.com/norayr/o7c/tree/master/tests) are some tests.

[this](https://github.com/norayr/o7c/blob/master/tests/hello/Unix.mod) illustrates how i used kernel calls directly, bypassing libc.

[this](https://github.com/norayr/o7c/tree/master/tests/hellolibc) illustrates how i used libc for the same purpose.

* vishap oberon


[vishap organization](https://github.com/vishaps/) github page.

[voc](https://github.com/vishaps/voc).

take a look at the [trace](http://norayr.am/files/2013-12-18/graph_dot.svg) on how voc compiles hello world file.

firstly, port to 64bit system was made, then addition of HUGEINT 64bit type, SYSTEM.ADDRESS - which is pointer size on every platform, cleanup of code of memory manager, bufixes in code generator, changes in symbol table handling. 

voc has [tests](https://github.com/vishaps/voc/tree/master/src/test/) directory.

there is my forking server, sound generation example, vt100 module, and [games](https://github.com/vishaps/voc/tree/master/src/test/x11) ported from classical oberon system via x11 wrapper.

click [here](http://norayr.am/oberon/voc/test.png) to see how tetris port looks. ([original archived blog post](https://web.archive.org/web/20170515222247/http://oberon.vishap.am/169-2/))

[here](http://norayr.am/oberon/voc/gtk.png) to see how gtk app looks, which is written in oberon.

[vipack](https://github.com/vishaps/vipack)

[click](https://camo.githubusercontent.com/bf681582db235fe2a06e1fc6affe05e4dc87ae00735b11a978bfbdeff6b327c7/68747470733a2f2f786e2d2d7939617a6573773662752e786e2d2d7939613361712f6d656469612f75706c6f6164732f323032322f30312f31392f34623635306162342d326539372d343566382d386664332d6166316337323633393963302e706e67) for the screenshot.

started as a [student project](http://norayr.am/papers/Thesis_Ruben_Khachatryan_CIS_2019.pdf) i revised.

later i implemented recoursive dependency resolver, the graph is on the screenshot by the link.

[vpicl](https://github.com/vishaps/vpicl)


this was just port of wirth's pic16f84 compiler. [screenshot](http://norayr.am/oberon/voc/vpicl__.png) at the page shows how the code generated by it executes in gpsim simulator.

voc is currently used in a ['freeoberon' ide](https://github.com/kekcleader/FreeOberon), not my project.

teaching
========

i keep notes with source code in public repositories on github.

notes for every year differ, but these are the examples:

[computer organization 2021 notes](https://github.com/comporg21/notes)  

[compiler design 2019 notes](https://github.com/compilers2019/notes)  

[operating systems 2017 notes](https://github.com/osdevnet/BBS/tree/master/notes)

repositories contain many references to troublespots and loopholes in language design.

i feel a need to explain why we need type checks [across module boundaries](https://github.com/comporg21/notes/tree/master/make/c) (modules existed since late 70ies, added to c++ standard in 2020).

why c# namespaces [don't solve](https://github.com/compilers2019/notes/tree/master/5/namespace) the problems c has.

on [fortran](https://github.com/compilers2019/notes/blob/master/5/note) problem.

on floating point accuracy problems [here](https://github.com/comporg21/notes/blob/master/currency_bcd/notes). also [this](https://github.com/comporg21/notes/blob/master/currency_bcd/imtec-92-26.pdf) pdf.

on arrays vs linked lists performance [here](https://github.com/comporg21/notes/tree/master/arrays_linked_lists)

on [endianness](https://github.com/comporg21/notes/tree/master/endianness) problems, like when typcasting.

on [buffer overflows](https://github.com/comporg21/notes/tree/master/stack/gets)

on [how by changing one byte in memory make function exit not to caller but to different location](https://github.com/comporg21/notes/tree/master/stack/stack_smashing/2)

on [getting values out of array index range](https://github.com/compilers2019/notes/blob/master/5/arr.c) which caused heartbleed bug in openssl library.

and [this](https://github.com/norayr/troublespots) is a small forgotten repo about c++.


other
====

irc
===

i have written this [irc bot](https://github.com/norayr/irc_bot) from scratch in oberon.

first [internet sockets wrapper](https://github.com/norayr/Internet/),  
then  [irc protocol](https://github.com/norayr/irc/) implementation,  

i also used other libraries or wrappers written by me, like [lists](https://github.com/norayr/lists) library for linked lists, [opts](https://github.com/norayr/opts) to parse commandline arguments, or very simple [unix time](https://github.com/norayr/lists/tree/4fec82f839b088e8cf6b640816b61ba8a2129c69) wrapper.


xmpp
====

contribution to the xmpp library written in pascal.
made crossplatform (to compile with lazarus) and added two methods, which were not implemented(i guess to get the avatar image from the server, and something else)

[commit link](https://github.com/devi/uxmpp/commit/1ffe8020590b76542d82c757228729a8ff65cb77)

this was done for my decentralized location sharing linux [mobile application](http://norayr.am/meridian23/).
first gif at that page shows how i approach synopsys building.

freepascal
==========

it did not build on my aarch64 pinebook, so i patched the ebuild:
[link](https://gentoobrowse.randomdan.homeip.net/packages/dev-lang/fpc) and other [link](https://bugs.gentoo.org/817899)

i also provided [this patch](https://gitlab.com/freepascal.org/fpc/documentation/-/issues/21107) in 2010.

python4delphi [commit](https://github.com/pyscripter/python4delphi/pull/413/commits/8a726f56c4dcdf6f8b9ca2a33b6544b36d3dca69) that fixes crossplatform/Lazarus builds.

maemo-leste
===========

as a result of discussion in #maemo-leste irc room, i did [this project](https://github.com/norayr/gen-header-for-hildon-input-method) to generate a header which will be used by maemo keyboard.

the [resulting header](https://github.com/norayr/gen-header-for-hildon-input-method/blob/master/out.h) contains two arrays: one of unicode codes, other for x key symbols.

it is generated by comparing [one of node files](https://github.com/substack/node-keysym/blob/master/data/keysyms.txt) with xorg [keysimdef.h](https://www.cl.cam.ac.uk/~mgk25/ucs/keysymdef.h) file.

this is [the commit](https://github.com/maemo-leste/hildon-input-method/commit/5dcba543c36c12ac70288a7b652310e275eebee7), which mentions me as inky (one of my irc nicknames).

brought extra keyboards (mentioned [here](https://maemo-leste.github.io/maemo-leste-thirteenth-update-april-may-june-2020.html) to the project from the other, outdated project, this is the [pull request](https://github.com/maemo-leste/hildon-input-method-plugins/pull/2) - this is nothing serious, but required skills to build the debian packages, edit makefiles, to make sure the new keyboards are registered in gconf and can be loaded via ui.

i also have a mobile linux application in maemo repos: [photolightmeter](https://github.com/maemo-leste-extras/photolightmeter) - it calculates aperture and shutter settings for old manual film cameras. initially written for [n900](https://www.my-maemo.com/software/applications_name_Photographic_Light_Meter_faq_36_fldAuto_2240.html)

the only interesting part there is that [i get](https://github.com/maemo-leste-extras/photolightmeter/blob/c707d055b76bcf56c2e1ea1a60575abb50548bed/lux.pas#L71) amount of light in lux by finding and analyzing driver files right in /sys directory.

i have published `android` port of the same program, compiled with delphi community edition:

[binary on play store](https://play.google.com/store/apps/details?id=com.embarcadero.photolightmeter&gl=US)

[source code branch on github](https://github.com/norayr/photolightmeter/tree/android)

the difference is how do i get the ambient light sensor information, this time by just [using a delphi class](https://github.com/norayr/photolightmeter/blob/ad36dabfa598d7badd6f98333af0cbcf2fc3ea86/lux.pas#L190).

illuria security
================

[manush](https://github.com/illuria/manush) (menu shell) that gets configuration from JSON file and draws menu. One of the options can be the other JSON file, and then manush will call manush. And correctly exit to parent manush.

maemo-leste ports & maintainership
==================================

I have enriched maemo-leste repositories by the following projects, which I mostly revived and brought to back to life, and sometimes ported/packaged (see git histories).

ports:

* [Amazfish](https://github.com/maemo-leste-extras/harbour-amazfish) - watch app and daemon.

* it also required porting [nemo-qml-plugin-dbus](https://github.com/maemo-leste-extras/nemo-qml-plugin-dbus) package.

* [lagrange](https://github.com/maemo-leste-extras/lagrange) - packaged SDL based mobile ui version of lagrange for mobile Linux. Usually Linux packagers package the desktop version, and only Android and IOS builds made by author use mobile ui.

revived applications:

* [live-wallpaper](https://github.com/maemo-leste-extras/live-wallpaper) is a maemo control panel applet.

* [shermans-aquarium-maemo](https://github.com/maemo-leste-extras/shermans-aquarium-maemo) is one of the plugins for live-wallpaper.

It is derived from the other old program [published on sourceforge](http://aquariumapplet.sourceforge.net/). That program didn't build for a long time, so I fixed and published it:

* [sherman's aquarium revived](https://github.com/norayr/shermans_aquarium)

for the windowmaker dockapp to work I also had to bring to life GAI library.

* [GAI](https://github.com/norayr/gai)

the build instructions are [here](https://github.com/norayr/shermans_aquarium/blob/main/readme.noch)

other maemo revivals:

* [easylist](https://github.com/maemo-leste-extras/easylist)
* [9x9 sudoku](https://github.com/maemo-leste-extras/9x9-sudoku)
* [mstardict](https://github.com/maemo-leste-extras/mstardict)
* [leafpad](https://github.com/maemo-leste-extras/leafpad)
* [maefat](https://github.com/maemo-leste-extras/maefat)
* [msid](https://github.com/maemo-leste-extras/msid)

phosh
=====

* squeekboard [patch](https://gitlab.gnome.org/World/Phosh/squeekboard/-/merge_requests/478#note_1297259) for armenian layouts.

suckless
========
svkbd [armenian layout](https://git.suckless.org/svkbd/commit/c247720ae49d166686ae23a7b9bd0e1dfb3b446b.html)

svkbd [dvorak layout](https://git.suckless.org/svkbd/commit/7fc78a0b445a1af10c7931bdf5d0f316605fa289.html)

my papers collection
====================

collection of papers interesting to me [here](http://norayr.am/papers/). keep nearby to find quickly.

translations of floss
=====================

i was a gnome armenian translations coordinator since 2005, but worked actively only for several years.

* [some mailing list proof](https://mail.gnome.org/archives/membership-committee/2005-September/msg00031.html)

* windowmaker translator.

* mandrake linux specific translations.

some public talks
============

(all in armenian)

systems we love armenia, dvorak? always has been: [https://youtu.be/9KI1bqz6S1Y](https://youtu.be/9KI1bqz6S1Y)

barcamp.am 2019 - everybody lies: OS, compiler, CPU. [https://www.youtube.com/watch?v=TpZvnkyMv6I](https://www.youtube.com/watch?v=TpZvnkyMv6I)

barcamp.am 2019 - modules [https://www.youtube.com/watch?v=ZFDdW_ClaLo](https://www.youtube.com/watch?v=ZFDdW_ClaLo)

barcamp.am 2014 - vishap oberon [https://www.youtube.com/watch?v=ZiKWZySzKrM](https://www.youtube.com/watch?v=ZiKWZySzKrM)

systems we love armenia, It's Pascal! I know it!: [https://www.youtube.com/watch?v=qN6n5c7h730](https://www.youtube.com/watch?v=qN6n5c7h730)
