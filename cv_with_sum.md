---
name: Norayr Chilingarian
keywords: programming languages, translation techniques, lexical analysis, syntax analysis, code generation, ebnf, syntax notation, context-free grammar, recourcsive descent parser, top-down parser, modular programming languages, module, safe programming, secure programming, machine code, operating systems design, dynamic module loading, linking, dynamic linking, oop, kernel, micro-kernel operating systems, oberon, oberon-2, native oberon, vishap oberon compiler, voc, active oberon, active objects, a2, aos, bluebottle, minix, plan9, inferno, threads, tasks, component systems, inter-process communication, package management, dependency resolution. 
left-column:
- 'programming languages'
- 'compiler construction'
- 'operating systems'
- 'systems programming'
right-column:
- 'email: [norayr@arnet.am](mailto:norayr@arnet.am)'
- 'xmpp:  [norayr@spyurk.am](mailto:norayr@arnet.am)'
- 'web: [https://norayr.am/](https://norayr.am/)'
- 'gemini: [gemini://norayr.am/](gemini://norayr.am/)'
- 'ssb:   @Y4+9YYlGp6rS2f7c1Phz7b+cpcQ8Ar9bTxN206Dem5o=.ed25519'
- 'github: [https://github.com/norayr/](https://github.com/norayr/)'
- 'age:  \themyage{} '
- 'this document was compiled: \today'
...

# Education
1994-1998; State Engineering University of Armenia

# Work experiences

## AUA
2017-; adjunct lecturer. Taught 'Operating systems' and 'Compiler Design' courses.

## ISTC
2020; instructor, Security Engineering course.

## Armenian Code Academy
2019; instructor, introduction to Linux for non-IT students.

## Vishap Oberon Compiler
2012-; founder and developer of [voc](https://github.com/vishaps/voc)

## barcamp.am
2010-; member of barcampevn organizing committee.

## Synopsys Armenia
2009-; IT engineer

* Solving problems, consulting developers in areas of systems programming, Unix, distributed computations, maintain and develop Synopsys Armenia and Synopsys/SEUA educational department IT infrastructure, including but not limited with: computational grids(UGE), On Demand Computing (openstack), storage system clusters, monitoring, DNS, CUPS, NIS, dhcp, etc services. Administering a network of more than 500 servers.
* Have been a research supervisor at Synopsys/SEUA educational department for several years.

## ETH Zurich
2007-2008; Assistant at Native Systems Group, Institute of Computer Systems, ETH Zurich.

* Ported latest (back then) edition of Revised Oberon compiler by Niklaus Wirth from StrongArm to x86 on GNU+Linux.

## Lycos Europe
2004-2007; Member of 'search team'.

* Participated in web search software development (it was running on fireball.de, paperball.de, lycos.eu) and port from TRU64 to GNU+Linux.
* Prepared standard of development environment.
* Hacking & patching software, including Apache web server and Spread messaging server.
* Maintaining debian apt archive mirror.
* Managed environment with more than 80 servers.
* Many research works.

## Technology Management Centre of Yerevan Municipality.
2003-2004; IT engineer.

* Unix (FreeBSD) servers administration: DNS, mail, file sharing, proxy, time servers, traffic shapers, routing setup.
* Secure network design by using virtualization (jail) and DMZ setups.
* Monitoring setup with Nagios, which back then was not supported on FreeBSD and needed to be adapted.
* Yerevan Municipality network and information area plan-concept and implementation.

## 'Informsvyaz' ISP (telex221.ru), Dubna, Russia.
2001-2002; Technical direcor.

* I had the opportunity to design and lead the implementation of the ISP from scratch: dial-up access, DSL leased lines, user management, quotas, email server with antivirus, hosting and more.
* Servers were running RedHat & Gentoo Linux, OpenBSD, Windows NT.

## Int@rnet ISP, Yerevan.
2000-2002; System administrator.

* Dial up servers configuration (Ascend, Patton)
* Got first experiente in Unix and network configuration with many services.
* Leased line and dial-up clients.
* Aironet radio modems.
* Quick reconstruction of networks.
* Security audit of web software.

## other
In late 90ies/early 2000s  I also worked as creative director at TV companies(Ar, Noyan Tapan), directed and edited commercials, music clips, short films, etc.

# Summary (with pieces of bio)

Sorry for the following essay, but its form, if not content, may describe me better than the 'Experiences' section.

I believe it is fair to describe myself as a curious and open person. But not as a particularly smart person, as you'll be convinced by taking a look at the text below.

It so happened that I am very interested in humans and in technologies, particularly in computers, and human-computer interaction.

Probably that's because I was directed into the area since childhood, was extremely privileged to own and use an 8bit computer. Nobody asked if I wanted that, but I am very thankful.

Though we had a shortage of books and magazines about computers in Soviet Armenia, and I had no one to ask questions, that was also a great learning experience: I learnt to be patient, I learnt to think for days, and stare at code for weeks, try things for months, I learnt that I'll inevitably understand what I want to, it just takes time.

Later I found out it doesn't work exactly like that in life, human societies, and relationships: I am still struggling to understand what is happening around.

To give the reader more context, back then I even learnt to read (and sometimes understand) the compiled machine code in hexadecimal representation, edit it, hack games, and gain immortality. That also doesn't work exactly like that in life, right? Or maybe no?

By reading the machine code of the old games I learnt many tricks (like self-modifying code) that do not always represent an academic way of programming. I am an advocate of the academic ways today, in case you wonder.

Then at the university, I worked with some outdated machines running MS-DOS, developed some primitive AI programs, and when I was back from the army I faced that 'Windows' (tm) system for the first time.

At the time I was not able to conduct even simple tasks with it, and people around were convinced me and computers have no connection whatsoever.

I did not look confident when touching the mouse, and nobody would suspect I did know how CPU's work and that my native language was a nmos6502 machine code: the CPU you may have interacted with if you met Apple ][, NES, Commodore, small Ataris, Oric or Soviet Agat systems.

It took some time and work and I was able to buy an outdated Pentium machine, and a couple of years later I was building my own Linux distributions from the source code, in a way I like to. Till today I use systems that I build myself from scratch.

Since contemporary systems are overly complicated, I keep my personal systems simple and minimal. It's easier to build, update, mantain, understand them that way.

Back to the story, that was a time when I got access to the Internet, discovered different technologies, and started reading research papers. I wish I got Internet earlier, it would help to start understanding earlier w h a t  i s  s c i e n c e  a b o u t.

Later I realized that programs I have been written in that time frame could be described as systems programming:  that software layer end-user doesn't interact with. I also love to design tools, that other people may use to program. Back then I wrote code generators, my Unix shell, dependency resolving package manager.

Some people perceive me as a 'Unix guy'. However, I believe that's not the case. I think today we know more about operating systems design, but backward compatibility keeps us back. I love to point out the signs of an old design in Unix, Windows, and macOS, and to tell about new approaches in research operating systems: Oberon family systems, Plan9, Inferno.

Still, I also appreciate the history and evolution of computer systems, and I do not blame but admire computer scientists who brought us the design we consider old today. 

I was so obsessed with Oberon technologies, that I somehow reached Switzerland, went to ETH Zurich, and even met the scientists I admired. Then I was lucky to be offered a job in the research group of N. Wirth(he was already retired, but he still works on many projects and sometimes comes to the faculcy), under the supervision of prof. J. Gutknecht, the other author of the Oberon system. There, while working at Native Systems Group, Institute of Computer Systems, ETH Zurich, I have ported N. Wirth's brand new Oberon-07 compiler to x86/Linux.

I am proud that I was called 'Encyclopedia Oberonica' by some members of the research group because I've read an incredible amount of Oberon-related scientific papers and they noticed I do refer to those papers sometimes.

Later I founded a libre software project, Vishap Oberon Compiler, which became well known in the community.  

Today my interests include hardware design and abstractions over it: programming languages, translation techniques, and operating systems. I am also interested in tools and working environment design.

I can describe myself as a digital minimalist: I avoid using many software and 'services'.  

I also value minimalistic design because complicating the design leads to inconsistencies and future problems, and I think too often we are busy solving problems that we have created ourselves. Also, more links in the chain - more possibility that something will break - less safety/stability.

I often suggest thinking more before adding a feature - once you add it, it's very hard to get rid of. When I do a design decision, and I don't see a good enough solution - I believe no solution is better than a bad solution, otherwise, later development on top of a bad solution will be very hard or impossible to roll back.

Did the reader wonder why "computers" work so "slowly" and "unreliably"? That's one of the reasons why.

The other advantage of minimalism is understandable design. I do like to look 'under the hood' and make sense of others' thoughts. That's not an easy task for people much smarter than me, even when the software is simple. Alas, some software layers humans built are not only impossible to understand for other humans, but even merely to use.

I believe it is better to search for simple solutions for complicated problems. For sure, I would not encourage the opposite: finding complex solutions when the simpler would suffice. The latter happens more often than necessary. (:

Bad design solutions lead to software that is easier to compromise. One of my major interests is techniques to increase software safety and security.

The approaches I described above would not be celebrated in industry work, where the goal is often to add more features, be fast and early on the market.

I advocate decentralized communication, I believe that the Internet is more than an access channel to a couple of big service providers. That is why I also host and maintain several nodes of decentralized 'social' networks for local communities.

I am obsessed with programming language design. I do believe the language we write in impacts the way we think. Expressing thoughts in a well-designed programming language helps to prevent software failures, hard-to-find errors, security flaws, and vulnerabilities. Using well-designed language teaches programmers the discipline they may benefit from, even when they have to work with not-so-well-designed programming languages.

My favourite programming languages are Oberon, Modula-3, Go.
I value Ada, Spark, Pascal(Extended, ISO standard), Swift, Rust, Forth, Erlang, Haskell, Lisp, Scala, Lua.
I would also say I value C and Objective C, but with a clause: they were created by brilliant computing pioneers when we were not aware of better design principles, and they still carry our past.

The past has a tendency to haunt us and keep us back.

Thank you for reading to this point.
